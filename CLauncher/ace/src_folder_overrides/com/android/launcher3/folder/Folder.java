/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.launcher3.folder;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ValueAnimator;
import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.view.FocusFinder;
import android.view.KeyEvent;
import android.view.View;
import android.view.ViewDebug;
import android.view.accessibility.AccessibilityEvent;
import android.view.inputmethod.EditorInfo;
import android.widget.LinearLayout;
import android.widget.OverScroller;
import android.widget.TextView;

import com.android.launcher3.Alarm;
import com.android.launcher3.AppInfo;
import com.android.launcher3.BubbleTextView;
import com.android.launcher3.CellLayout;
import com.android.launcher3.DeviceProfile;
import com.android.launcher3.DragSource;
import com.android.launcher3.DropTarget;
import com.android.launcher3.FolderInfo;
import com.android.launcher3.ItemInfo;
import com.android.launcher3.Launcher;
import com.android.launcher3.LauncherAnimUtils;
import com.android.launcher3.LauncherSettings;
import com.android.launcher3.LauncherState;
import com.android.launcher3.OnAlarmListener;
import com.android.launcher3.R;
import com.android.launcher3.ShortcutAndWidgetContainer;
import com.android.launcher3.ShortcutInfo;
import com.android.launcher3.Utilities;
import com.android.launcher3.Workspace;
import com.android.launcher3.accessibility.AccessibleDragListenerAdapter;
import com.android.launcher3.anim.LocateAnimationHelper;
import com.android.launcher3.config.FeatureFlags;
import com.android.launcher3.dragndrop.DragController;
import com.android.launcher3.dragndrop.DragLayer;
import com.android.launcher3.dragndrop.DragOptions;
import com.android.launcher3.uioverrides.UiFactory;
import com.android.launcher3.userevent.nano.LauncherLogProto;
import com.android.launcher3.util.Thunk;
import com.android.launcher3.views.BaseDragLayer;
import com.android.launcher3.widget.PendingAddShortcutInfo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import androidx.annotation.NonNull;
import androidx.core.view.NestedScrollingParent;
import androidx.dynamicanimation.animation.FloatPropertyCompat;
import androidx.dynamicanimation.animation.SpringAnimation;
import androidx.dynamicanimation.animation.SpringForce;

import static androidx.dynamicanimation.animation.SpringForce.DAMPING_RATIO_MEDIUM_BOUNCY;
import static androidx.dynamicanimation.animation.SpringForce.STIFFNESS_LOW;
import static androidx.dynamicanimation.animation.SpringForce.STIFFNESS_MEDIUM;
import static com.android.launcher3.LauncherState.NORMAL;
import static com.android.launcher3.LauncherState.SPRING_LOADED;
import static com.android.launcher3.compat.AccessibilityManagerCompat.sendCustomAccessibilityEvent;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource,
        View.OnLongClickListener, DropTarget, FolderInfo.FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener, DragController.DragListener, NestedScrollingParent {
    private static final String TAG = "Launcher.Folder";

    /**
     * We avoid measuring {@link #mContent} with a 0 width or height, as this
     * results in CellLayout being measured as UNSPECIFIED, which it does not support.
     */
    private static final int MIN_CONTENT_DIMEN = 5;

    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    private static final int REORDER_DELAY = 250;
    private static final int ON_EXIT_CLOSE_DELAY = 400;
    private static final Rect sTempRect = new Rect();

    private static String sDefaultFolderName;
    private static String sHintText;

    private final Alarm mReorderAlarm = new Alarm();
    private final Alarm mOnExitAlarm = new Alarm();

    @Thunk
    final ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();

    private AnimatorSet mCurrentAnimator;

    protected final Launcher mLauncher;
    protected DragController mDragController;
    public FolderInfo mInfo;

    @Thunk
    FolderIcon mFolderIcon;

    @Thunk
    FolderCellLayout mContent;

    @Thunk
    FolderScrollView mScrollView;
    public FolderEditText mFolderName;

    // Cell ranks used for drag and drop
    @Thunk int mTargetRank, mPrevTargetRank, mEmptyCellRank;

    private FolderPagesContainer mContainer;

    @ViewDebug.ExportedProperty(category = "launcher",
            mapping = {
                    @ViewDebug.IntToString(from = STATE_NONE, to = "STATE_NONE"),
                    @ViewDebug.IntToString(from = STATE_SMALL, to = "STATE_SMALL"),
                    @ViewDebug.IntToString(from = STATE_ANIMATING, to = "STATE_ANIMATING"),
                    @ViewDebug.IntToString(from = STATE_OPEN, to = "STATE_OPEN"),
            })
    @Thunk int mState = STATE_NONE;
    @ViewDebug.ExportedProperty(category = "launcher")
    private boolean mRearrangeOnClose = false;
    boolean mItemsInvalidated = false;
    private View mCurrentDragView;
    private boolean mIsExternalDrag;
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;
    @Thunk float mFolderIconPivotX;
    @Thunk float mFolderIconPivotY;
    private boolean mIsEditingName = false;

    @ViewDebug.ExportedProperty(category = "launcher")
    private boolean mDestroyed;

    private final FolderHover mHover;
    private ValueAnimator mDragOutlineAnimator;
    private ValueAnimator mScrollbarAnimator;
    private final Rect mBackgroundBounds = new Rect();
    private final GradientDrawable mScrollbar;
    private String mOldName;
    private final FolderRenameDialog mRenameDialog;
    private AnimatorSet mLocateAnimation;
    public boolean mSnapToLastpage;

    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attributes set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);
        setAlwaysDrawnWithCacheEnabled(false);
        Resources res = getResources();

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        if (sHintText == null) {
            sHintText = res.getString(R.string.folder_hint_text);
        }
        mLauncher = Launcher.getLauncher(context);
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behavior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
        mHover = new FolderHover();
        mContainer = mLauncher.getFolderPagesContainer();
        mScrollbar = (GradientDrawable) getResources().getDrawable(R.drawable.folder_scoll_bar,
                context.getTheme());
        mScrollbar.setBounds(0, 0,
                Utilities.pxFromDp(2, getResources().getDisplayMetrics()), 0);
        mRenameDialog = new FolderRenameDialog(context, this);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mScrollView = findViewById(R.id.folder_scroll);
        mScrollView.setFolder(this);

        mContent = findViewById(R.id.folder_content);
        mContent.setFolder(this);

        mFolderName = mRenameDialog.getFolderName();

        getBackground().setAlpha(0);
    }

    public boolean onLongClick(View v) {
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;
        if (mLauncher.isInEditMode()) return true;
        return startDrag(v, new DragOptions());
    }

    public boolean startDrag(View v, DragOptions options) {
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            setDragOutlineVisible(true);

            ShortcutInfo item = (ShortcutInfo) tag;

            mEmptyCellRank = item.rank;
            mCurrentDragView = v;

            mDragController.addDragListener(this);
            if (options.isAccessibleDrag) {
                mDragController.addDragListener(new AccessibleDragListenerAdapter(
                        mContent, CellLayout.FOLDER_ACCESSIBILITY_DRAG));
            }

            mLauncher.getWorkspace().beginDragShared(v, this, options);
        }
        return true;
    }

    @Override
    public void onDragStart(DropTarget.DragObject dragObject, DragOptions options) {
        if (dragObject.dragSource != this) {
            return;
        }

        mContent.removeView(mCurrentDragView);
        if (dragObject.dragInfo instanceof ShortcutInfo) {
            mItemsInvalidated = true;

            // We do not want to get events for the item being removed, as they will get handled
            // when the drop completes
            try (SuppressInfoChanges s = new SuppressInfoChanges()) {
                mInfo.remove((ShortcutInfo) dragObject.dragInfo, true);
            }
        }
        mDragInProgress = true;
        mItemAddedBackToSelfViaIcon = false;
    }

    @Override
    public void onDragEnd() {
        if (mIsExternalDrag && mDragInProgress) {
            completeDragExit();
        }
        setDragOutlineVisible(false);
        mDragInProgress = false;
        mDragController.removeDragListener(this);
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void startEditingFolderName() {
        post(this::startEditingFolderNameImmediate);
    }

    public void startEditingFolderNameImmediate() {
        mFolderName.setText(mInfo.title);
        mOldName = mFolderName.getText().toString();

        if (mRenameDialog != null) {
            mRenameDialog.startEditFolderName();
        }
        mIsEditingName = true;
    }

    public void doneEditingFolderName() {
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();

        if (TextUtils.isEmpty(newTitle.trim())) {
            if (TextUtils.isEmpty(mOldName.trim())) {
                newTitle = getContext().getString(R.string.folder_name);
            } else {
                newTitle = mOldName;
            }
        }

        if (isCategoryFolder()) {
            if (!newTitle.trim().equals(mOldName.trim())) {
                //mInfo.options &= ~FolderInfo.FLAG_CATEGORY_FOLDER;
            }
        }

        mInfo.setTitle(newTitle);
        mLauncher.getModelWriter().updateItemInDatabase(mInfo);

        mContainer.updateCurrentTab();

        sendCustomAccessibilityEvent(
                this, AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                getContext().getString(R.string.folder_renamed, newTitle));
        requestFocus();
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            mFolderName.dispatchBackKey();
            return true;
        }
        return false;
    }

    public FolderIcon getFolderIcon() {
        return mFolderIcon;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    public void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    protected void onAttachedToWindow() {
        // requestFocus() causes the focus onto the folder itself, which doesn't cause visual
        // effect but the next arrow key can start the keyboard focus inside of the folder, not
        // the folder itself.
        requestFocus();
        super.onAttachedToWindow();
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    @Override
    public View focusSearch(int direction) {
        // When the folder is focused, further focus search should be within the folder contents.
        return FocusFinder.getInstance().findNextFocus(this, null, direction);
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    public FolderInfo getInfo() {
        return mInfo;
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;
        Collections.sort(children, ITEM_POS_COMPARATOR);
        mContent.bindItems(children);

        BaseDragLayer.LayoutParams lp = (BaseDragLayer.LayoutParams) mContainer.getLayoutParams();
        if (lp == null) {
            lp = new BaseDragLayer.LayoutParams(0, 0);
            mContainer.setLayoutParams(lp);
        }
        centerAboutIcon();

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        if (!sDefaultFolderName.contentEquals(mInfo.title)) {
            mFolderName.setText(mInfo.title);
            mFolderName.setHint(null);
        } else {
            mFolderName.setText("");
            mFolderName.setHint(sHintText);
        }

        // In case any children didn't come across during loading, clean up the folder accordingly
        mFolderIcon.post(new Runnable() {
            public void run() {
                if (getItemCount() <= getMinimumItemCount()) {
                    replaceFolderWithFinalItem();
                }
            }
        });
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param launcher The main activity.
     *
     * @return A new UserFolder.
     */
    @SuppressLint("InflateParams")
    static Folder fromXml(Launcher launcher) {
        return (Folder) launcher.getLayoutInflater()
                .inflate(R.layout.user_folder_icon_normalized, null);
    }

    private void startAnimation(final AnimatorSet a) {
        if (mCurrentAnimator != null && mCurrentAnimator.isRunning()) {
            mCurrentAnimator.cancel();
        }
        a.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                mState = STATE_ANIMATING;
                mCurrentAnimator = a;
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                mCurrentAnimator = null;
            }
        });
        a.start();
    }

    /**
     * Opens the user folder described by the specified tag. The opening of the folder
     * is animated relative to the specified View. If the View is null, no animation
     * is played.
     */
    public void animateOpen() {
        if (mContainer.isOpen()) {
            // Close any open folder before opening a folder.
            mContainer.close(true);
        }

        DragLayer dragLayer = mLauncher.getDragLayer();
        // Just verify that the folder hasn't already been added to the DragLayer.
        // There was a one-off crash where the folder had a parent already.
        if (mContainer.getParent() == null) {
            DragLayer.LayoutParams lp = new DragLayer.LayoutParams(
                    DragLayer.LayoutParams.MATCH_PARENT, DragLayer.LayoutParams.MATCH_PARENT
            );
            lp.x = 0;
            lp.y = 0;
            dragLayer.addView(mContainer, lp);
            mContainer.handleOpen(this);
            if (mLauncher.isInEditMode()) {
                mLauncher.getEditModePanel().bringToFront();
            }

            mDragController.addDropTarget(this);
        } else {
            if (FeatureFlags.IS_DOGFOOD_BUILD) {
                Log.e(TAG, "Opening folder (" + this + ") which already has a parent:"
                        + getParent());
            }
        }

        scrollToTop();

        // This is set to true in close(), but isn't reset to false until onDropCompleted(). This
        // leads to an inconsistent state if you drag out of the folder and drag back in without
        // dropping. One resulting issue is that replaceFolderWithFinalItem() can be called twice.
        mDeleteFolderOnDropCompleted = false;

        centerAboutIcon();

        AnimatorSet anim = new FolderAnimationManager(this, true /* isOpening */).getAnimator();
        anim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                //liuzuo : remove folder icon invisible :start
                //mFolderIcon.setBackgroundVisible(false);
                //liuzuo : remove folder icon invisible :end
                mFolderIcon.drawLeaveBehindIfExists();
                UiFactory.setBackButtonAlpha(mLauncher, 1, true);
            }
            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;

                setDragOutlineVisible(mDragInProgress);
                mLauncher.setWorkspaceAlpha(0, true);

                if (mAnimationCompleteRunnable != null) {
                    mAnimationCompleteRunnable.run();
                    mAnimationCompleteRunnable = null;
                }

                mLauncher.getUserEventDispatcher().resetElapsedContainerMillis("folder opened");
                mContent.setFocusOnFirstChild();
            }
        });

        startAnimation(anim);

        // Make sure the folder picks up the last drag move even if the finger doesn't move.
        if (mDragController.isDragging()) {
            mDragController.forceTouchMove();
        }

        mContent.verifyVisibleHighResIcons();
        //liuzuo:add the background of workspace when opening folder:begin
        mLauncher.openOrCloseFolderAnimation(true,null);
        //liuzuo:add the background of workspace when opening folder:end
    }

    public void openSilent() {
        mDragController.addDropTarget(this);

        centerAboutIcon();

        scrollToTop();
        getBackground().setAlpha(0);

        mFolderIcon.setBackgroundVisible(false);
        mFolderIcon.drawLeaveBehindIfExists();

        mDeleteFolderOnDropCompleted = false;

        if (mDragController.isDragging()) {
            mDragController.forceTouchMove();
        }

        mContent.verifyVisibleHighResIcons();

        mState = STATE_OPEN;
    }

    public void closeSilent() {
        if (isEditingName()) {
            mFolderName.dispatchBackKey();
        }

        if (mFolderIcon != null) {
            mFolderIcon.clearLeaveBehindIfExists();
            mFolderIcon.setVisibility(View.VISIBLE);
            mFolderIcon.setBackgroundVisible(true);
            mFolderIcon.mFolderName.setTextVisibility(true);
        }

        if (mDragOutlineAnimator != null) {
            mDragOutlineAnimator.cancel();
        }
        getBackground().setAlpha(0);

        scrollToTop();

        mDragController.removeDropTarget(this);

        if (mRearrangeOnClose) {
            rearrangeChildren();
            mRearrangeOnClose = false;
        }
        if (getItemCount() <= getMinimumItemCount()) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
        clearDragInfo();
        mState = STATE_SMALL;
    }

    public void beginExternalDrag() {
        mEmptyCellRank = mContent.allocateRankForNewItem();
        mIsExternalDrag = true;
        mDragInProgress = true;

        // Since this folder opened by another controller, it might not get onDrop or
        // onDropComplete. Perform cleanup once drag-n-drop ends.
        mDragController.addDragListener(this);
    }

    public void closeFolder(boolean animate) {
        closeFolder(animate, null);
    }

    public void closeFolder(boolean animate, final Runnable r) {
        cancelLocateAnimation();

        if (isEditingName()) {
            mFolderName.dispatchBackKey();
        }

        if (mRenameDialog != null &&
                mRenameDialog.isShowing()) {
            mRenameDialog.doneEditFolderName();
        }

        if (mFolderIcon != null) {
            mFolderIcon.clearLeaveBehindIfExists();
        }

        if (mDragOutlineAnimator != null) {
            mDragOutlineAnimator.cancel();
        }

        mLauncher.setWorkspaceAlpha(1, true);
        if (!mLauncher.isInState(LauncherState.EDIT_MODE)) {
            UiFactory.setBackButtonAlpha(mLauncher, 0, true);
        }

        if (!(mContainer.getParent() instanceof DragLayer)) return;
        if (animate) {
            animateClosed(r);
        } else {
            closeComplete(false);
            if (r != null) {
                r.run();
            }
        }

        // Notify the accessibility manager that this folder "window" has disappeared and no
        // longer occludes the workspace items
        mLauncher.getDragLayer().sendAccessibilityEvent(
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
        //liuzuo:add the background of workspace when opening folder:begin
        mLauncher.openOrCloseFolderAnimation(false,null);
        //liuzuo:add the background of workspace when opening folder:end
    }

    private void animateClosed(Runnable r) {
        AnimatorSet a = new FolderAnimationManager(this, false /* isOpening */).getAnimator();
        a.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                closeComplete(true);
                mAnimationCompleteRunnable = null;
                if (r != null) {
                    r.run();
                }
            }
        });
        startAnimation(a);
    }

    private void closeComplete(boolean wasAnimated) {
        // TODO: Clear all active animations.
        DragLayer parent = (DragLayer) mContainer.getParent();
        if (parent != null) {
            parent.removeView(mContainer);
        }
        mDragController.removeDropTarget(this);
        clearFocus();
        if (mFolderIcon != null) {
            mFolderIcon.setVisibility(View.VISIBLE);
            mFolderIcon.setBackgroundVisible(true);
            mFolderIcon.mFolderName.setTextVisibility(true);
            if (wasAnimated) {
                mFolderIcon.mBackground.fadeInBackgroundShadow();
                mFolderIcon.mBackground.animateBackgroundStroke();
                mFolderIcon.onFolderClose();
                if (mFolderIcon.hasBadge()) {
                    mFolderIcon.createBadgeScaleAnimator(0f, 1f).start();
                }
                mFolderIcon.requestFocus();
            }
        }

        if (mRearrangeOnClose) {
            rearrangeChildren();
            mRearrangeOnClose = false;
        }
        if (getItemCount() <= getMinimumItemCount()) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
        clearDragInfo();
        mState = STATE_SMALL;
    }

    @Override
    public boolean acceptDrop(DragObject d) {
        final ItemInfo item = d.dragInfo;
        final int itemType = item.itemType;
        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT));
    }

    public void onDragEnter(DragObject d) {
        mPrevTargetRank = -1;
        mOnExitAlarm.cancelAlarm();
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            mContent.realTimeReorder(mEmptyCellRank, mTargetRank);
            mEmptyCellRank = mTargetRank;
        }
    };

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    private int getTargetRank(DragObject d, float[] recycle) {
        recycle = d.getVisualCenter(recycle);
        return mContent.findNearestArea(
                (int) recycle[0] - getPaddingLeft(), (int) recycle[1] - getPaddingTop()
            + mScrollView.getScrollY());
    }

    @SuppressLint("StringFormatMatches")
    @Override
    public void onDragOver(DragObject d) {
        final float[] r = new float[2];
        mTargetRank = getTargetRank(d, r);

        if (mTargetRank != mPrevTargetRank) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
            mReorderAlarm.setAlarm(REORDER_DELAY);
            mPrevTargetRank = mTargetRank;

            if (d.stateAnnouncer != null) {
                d.stateAnnouncer.announce(getContext().getString(R.string.move_to_position,
                        mTargetRank + 1));
            }
        }
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        if (mContainer.isOpen()) {
            mContainer.close(true);
            mRearrangeOnClose = true;
        } else if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            rearrangeChildren();
            clearDragInfo();
        }
    }

    private void clearDragInfo() {
        mCurrentDragView = null;
        mIsExternalDrag = false;
    }

    public void onDragExit(DragObject d) {
        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        }
        mReorderAlarm.cancelAlarm();
    }

    /**
     * When performing an accessibility drop, onDrop is sent immediately after onDragEnter. So we
     * need to complete all transient states based on timers.
     */
    @Override
    public void prepareAccessibilityDrop() {
        if (mReorderAlarm.alarmPending()) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarmListener.onAlarm(mReorderAlarm);
        }
    }

    public void onDropCompleted(final View target, final DragObject d,
            final boolean success) {

        if (success) {
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon && target != this) {
                replaceFolderWithFinalItem();
            }
        } else {
            // The drag failed, we need to return the item to the folder
            ShortcutInfo info = (ShortcutInfo) d.dragInfo;
            View icon = (mCurrentDragView != null && mCurrentDragView.getTag() == info)
                    ? mCurrentDragView : mContent.createNewView(info);
            ArrayList<View> views = getItemsInReadingOrder();
            views.add(info.rank, icon);
            mContent.arrangeChildren(views, views.size());
            mItemsInvalidated = true;

            try (SuppressInfoChanges s = new SuppressInfoChanges()) {
                mFolderIcon.onDrop(d, true /* itemReturnedOnFailedDrop */);
            }
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                if (!success) {
                    mSuppressFolderDeletion = true;
                }
                completeDragExit();
            }
        }

        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragView = null;

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch();

        // Show the animation, next time something is added to the folder.
        mInfo.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, false,
                mLauncher.getModelWriter());
    }

    private void updateItemLocationsInDatabaseBatch() {
        ArrayList<View> list = getItemsInReadingOrder();
        ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            info.rank = i;
            items.add(info);
        }

        mLauncher.getModelWriter().moveItemsInDatabase(items, mInfo.id, 0);
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return mState != STATE_ANIMATING;
    }


    private void centerAboutIcon() {
        DeviceProfile grid = mLauncher.getDeviceProfile();

        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        int width = getFolderWidth();
        int height = getFolderHeight();

        parent.getDescendantRectRelativeToSelf(mFolderIcon, sTempRect);
        int centerX = sTempRect.centerX();
        int centerY = sTempRect.centerY();
        int centeredLeft = centerX - width / 2;
        int centeredTop = centerY - height / 2;

        // We need to bound the folder to the currently visible workspace area
        if (mLauncher.getStateManager().getState().overviewUi) {
            mLauncher.getDragLayer().getDescendantRectRelativeToSelf(mLauncher.getOverviewPanel(),
                    sTempRect);
        } else {
            mLauncher.getWorkspace().getPageAreaRelativeToDragLayer(sTempRect);
        }

        final int left = (grid.availableWidthPx - width) / 2;
        final int top = sTempRect.top + (sTempRect.height() - height) / 2;

        int folderPivotX = width / 2 + (centeredLeft - left);
        int folderPivotY = height / 2 + (centeredTop - top);
        setPivotX(folderPivotX);
        setPivotY(folderPivotY);

        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
                (1.0f * folderPivotX / width));
        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
                (1.0f * folderPivotY / height));
    }

    public float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    public float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    private int getContentAreaHeight() {
        return Math.max(mContent.getDesiredHeight()
                , mContent.getMaxCountHeight());
    }

    private int getContentMaxCountHeight() {
        DeviceProfile grid = mLauncher.getDeviceProfile();
        int maxContentAreaHeight = grid.availableHeightPx
                - grid.getTotalWorkspacePadding().y;
        int height = Math.min(maxContentAreaHeight,
                mContent.getMaxCountHeight());
        return Math.max(height, MIN_CONTENT_DIMEN);
    }

    private int getContentDisplayHeight() {
        DeviceProfile grid = mLauncher.getDeviceProfile();
        int maxContentAreaHeight = grid.availableHeightPx
                - grid.getTotalWorkspacePadding().y;
        int height = Math.min(maxContentAreaHeight,
                mContent.getDisplayHeight());
        return Math.max(height, MIN_CONTENT_DIMEN);
    }

    private int getContentAreaWidth() {
        return Math.max(mContent.getDesiredWidth(), MIN_CONTENT_DIMEN);
    }

    public int getDisplayWidth() {
        return getFolderWidth();
    }

    public int getDisplayHeight() {
        return getFolderHeight(getContentDisplayHeight());
    }

    public int getFolderWidth() {
        return getPaddingLeft() + getPaddingRight() + getContentAreaWidth();
    }

    public int getFolderHeight() {
        return getFolderHeight(getContentMaxCountHeight());
    }

    private int getFolderHeight(int contentAreaHeight) {
        return getPaddingTop() + getPaddingBottom() + contentAreaHeight;
    }

    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int contentWidth = getContentAreaWidth();
        int contentHeight = getContentAreaHeight();

        int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(contentWidth, MeasureSpec.EXACTLY);
        int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(contentHeight, MeasureSpec.EXACTLY);
        mContent.setFixedSize(contentWidth, contentHeight);
        mContent.measure(contentAreaWidthSpec, contentAreaHeightSpec);

        int folderWidth = getFolderWidth();
        int folderHeight = getFolderHeight();

        mScrollView.measure(contentAreaWidthSpec,
                MeasureSpec.makeMeasureSpec(folderHeight, MeasureSpec.EXACTLY));

        setMeasuredDimension(folderWidth, folderHeight);
    }

    /**
     * Rearranges the children based on their rank.
     */
    public void rearrangeChildren() {
        rearrangeChildren(-1);
    }

    /**
     * Rearranges the children based on their rank.
     * @param itemCount if greater than the total children count, empty spaces are left at the end,
     * otherwise it is ignored.
     */
    public void rearrangeChildren(int itemCount) {
        ArrayList<View> views = getItemsInReadingOrder();
        mContent.arrangeChildren(views, Math.max(itemCount, views.size()));
        mItemsInvalidated = true;
    }

    public int getItemCount() {
        return mContent.getItemCount();
    }

    @Thunk void replaceFolderWithFinalItem() {
        if (getMinimumItemCount() == 0) {
            int itemCount = mInfo.contents.size();
            if (itemCount <= 0) {
                mLauncher.removeItem(mFolderIcon, mInfo, true /* deleteFromDb */);
                if (mFolderIcon instanceof DropTarget) {
                    mDragController.removeDropTarget((DropTarget) mFolderIcon);
                }
            }
            mDestroyed = true;
            return;
        }

        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                int itemCount = mInfo.contents.size();
                if (itemCount <= 1) {
                    View newIcon = null;

                    if (itemCount == 1) {
                        // Move the item from the folder to the workspace, in the position of the
                        // folder
                        CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container,
                                mInfo.screenId);
                        ShortcutInfo finalItem = mInfo.contents.remove(0);
                        newIcon = mLauncher.createShortcut(cellLayout, finalItem);
                        mLauncher.getModelWriter().addOrMoveItemInDatabase(finalItem,
                                mInfo.container, mInfo.screenId, mInfo.cellX, mInfo.cellY);
                    }

                    // Remove the folder
                    mLauncher.removeItem(mFolderIcon, mInfo, true /* deleteFromDb */);
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }

                    if (newIcon != null) {
                        // We add the child after removing the folder to prevent both from existing
                        // at the same time in the CellLayout.  We need to add the new item with
                        // addInScreenFromBind() to ensure that hotseat items are placed correctly.
                        mLauncher.getWorkspace().addInScreenFromBind(newIcon, mInfo);

                        // Focus the newly created child
                        newIcon.requestFocus();
                    }
                }
            }
        };
        View finalChild = mContent.getLastItem();
        if (finalChild != null) {
            mFolderIcon.performDestroyAnimation(onCompleteRunnable);
        } else {
            onCompleteRunnable.run();
        }
        mDestroyed = true;
    }

    public boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the first and last item in the folder for the purposes
    // of keyboard focus
    public void updateTextViewFocus() {
        final View firstChild = mContent.getFirstItem();
        final View lastChild = mContent.getLastItem();
        if (firstChild != null && lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
            // Hitting TAB from the folder name wraps around to the first item on the current
            // folder page, and hitting SHIFT+TAB from that item wraps back to the folder name.
            mFolderName.setNextFocusForwardId(firstChild.getId());
            // When clicking off the folder when editing the name, this Folder gains focus. When
            // pressing an arrow key from that state, give the focus to the first item.
            this.setNextFocusDownId(firstChild.getId());
            this.setNextFocusRightId(firstChild.getId());
            this.setNextFocusLeftId(firstChild.getId());
            this.setNextFocusUpId(firstChild.getId());
            // When pressing shift+tab in the above state, give the focus to the last item.
            setOnKeyListener(new OnKeyListener() {
                @Override
                public boolean onKey(View v, int keyCode, KeyEvent event) {
                    boolean isShiftPlusTab = keyCode == KeyEvent.KEYCODE_TAB &&
                            event.hasModifiers(KeyEvent.META_SHIFT_ON);
                    if (isShiftPlusTab && Folder.this.isFocused()) {
                        return lastChild.requestFocus();
                    }
                    return false;
                }
            });
        }
    }

    public void onDrop(DragObject d, DragOptions options) {
        PendingAddShortcutInfo pasi = d.dragInfo instanceof PendingAddShortcutInfo
                ? (PendingAddShortcutInfo) d.dragInfo : null;
        ShortcutInfo pasiSi = pasi != null ? pasi.activityInfo.createShortcutInfo() : null;
        if (pasi != null && pasiSi == null) {
            // There is no ShortcutInfo, so we have to go through a configuration activity.
            pasi.container = mInfo.id;
            pasi.rank = mEmptyCellRank;

            mLauncher.addPendingItem(pasi, pasi.container, pasi.screenId, null, pasi.spanX,
                    pasi.spanY);
            d.deferDragViewCleanupPostAnimation = false;
            mRearrangeOnClose = true;
        } else {
            final ShortcutInfo si;
            if (pasiSi != null) {
                si = pasiSi;
            } else if (d.dragInfo instanceof AppInfo) {
                // Came from all apps -- make a copy.
                si = ((AppInfo) d.dragInfo).makeShortcut();
            } else {
                // ShortcutInfo
                si = (ShortcutInfo) d.dragInfo;
            }

            View currentDragView;
            if (mIsExternalDrag) {
                currentDragView = mContent.createAndAddViewForRank(si, mEmptyCellRank);

                // Actually move the item in the database if it was an external drag. Call this
                // before creating the view, so that ShortcutInfo is updated appropriately.
                mLauncher.getModelWriter().addOrMoveItemInDatabase(
                        si, mInfo.id, 0, si.cellX, si.cellY);

                // We only need to update the locations if it doesn't get handled in
                // #onDropCompleted.
                if (d.dragSource != this) {
                    updateItemLocationsInDatabaseBatch();
                }
                mIsExternalDrag = false;
            } else {
                currentDragView = mCurrentDragView;
                mContent.addViewForRank(currentDragView, si, mEmptyCellRank);
            }

            if (d.dragView.hasDrawn()) {
                // Temporarily reset the scale such that the animation target gets calculated
                // correctly.
                float scaleX = getScaleX();
                float scaleY = getScaleY();
                setScaleX(1.0f);
                setScaleY(1.0f);
                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, currentDragView, null);
                setScaleX(scaleX);
                setScaleY(scaleY);
            } else {
                d.deferDragViewCleanupPostAnimation = false;
                currentDragView.setVisibility(VISIBLE);
            }

            mItemsInvalidated = true;
            rearrangeChildren();

            // Temporarily suppress the listener, as we did all the work already here.
            try (SuppressInfoChanges s = new SuppressInfoChanges()) {
                mInfo.add(si, false);
            }
        }

        // Clear the drag info, as it is no longer being dragged.
        mDragInProgress = false;

        mLauncher.getStateManager().goToStateFrom(NORMAL, SPRING_LOADED,
                LauncherAnimUtils.SPRING_LOADED_EXIT_DELAY);
        if (d.stateAnnouncer != null) {
            d.stateAnnouncer.completeAction(R.string.item_moved);
        }
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    public void hideItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        v.setVisibility(INVISIBLE);
    }
    public void showItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        v.setVisibility(VISIBLE);
    }

    @Override
    public void onAdd(ShortcutInfo item, int rank) {
        View view = mContent.createAndAddViewForRank(item, rank);
            mLauncher.getModelWriter().addOrMoveItemInDatabase(
                    item, mInfo.id, 0, item.cellX, item.cellY);

        ArrayList<View> items = new ArrayList<>(getItemsInReadingOrder());
        items.add(rank, view);
        mContent.arrangeChildren(items, items.size());
        mItemsInvalidated = true;
    }

    @Override
    public void onRemove(ShortcutInfo item) {
        mItemsInvalidated = true;
        View v = getViewForInfo(item);
        mContent.removeView(v);
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            rearrangeChildren();
        }
        if (getItemCount() <= getMinimumItemCount()) {
            if (mContainer.isOpen()) {
                mContainer.close(true);
            } else {
                replaceFolderWithFinalItem();
            }
        }
    }

    private View getViewForInfo(final ShortcutInfo item) {
        return mContent.iterateOverItems(new Workspace.ItemOperator() {

            @Override
            public boolean evaluate(ItemInfo info, View view) {
                return info == item;
            }
        });
    }

    @Override
    public void onItemsChanged(boolean animate) {
        updateTextViewFocus();
    }

    @Override
    public void prepareAutoUpdate() {
        mContainer.close(false);
    }

    @Override
    public void onAddIconInfo(ArrayList<ShortcutInfo> items) {

    }

    @Override
    public void onRemoveIconInfo(ArrayList<ShortcutInfo> items) {

    }

    @Override
    public void onClearIconInfo() {

    }


    public void onTitleChanged(CharSequence title) {
    }

    public ArrayList<View> getItemsInReadingOrder() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            mContent.iterateOverItems(new Workspace.ItemOperator() {

                @Override
                public boolean evaluate(ItemInfo info, View view) {
                    mItemsInReadingOrder.add(view);
                    return false;
                }
            });
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public List<BubbleTextView> getFolderItems() {
        return getItemsInReadingOrder().stream().map(v->(BubbleTextView)v).collect(Collectors.toList());
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName) {
            if (hasFocus) {
                startEditingFolderName();
            } else {
                mFolderName.dispatchBackKey();
            }
        }
    }

    @Override
    public void getHitRectRelativeToDragLayer(Rect outRect) {
        DragLayer layer = mLauncher.getDragLayer();
        layer.getViewRectRelativeToSelf(this, outRect);
        outRect.top -= (getScrollY() < 0 ? getScrollY() : 0);
        outRect.bottom = outRect.top + getDisplayHeight();
    }

    @Override
    public void fillInLogContainerData(View v, ItemInfo info, LauncherLogProto.Target target, LauncherLogProto.Target targetParent) {
        target.gridX = info.cellX;
        target.gridY = info.cellY;
        target.pageIndex = 0;
        targetParent.containerType = LauncherLogProto.ContainerType.FOLDER;
    }

    // Compares item position based on rank and position giving priority to the rank.
    public static final Comparator<ItemInfo> ITEM_POS_COMPARATOR = new Comparator<ItemInfo>() {

        @Override
        public int compare(ItemInfo lhs, ItemInfo rhs) {
            if (lhs.rank != rhs.rank) {
                return lhs.rank - rhs.rank;
            } else if (lhs.cellY != rhs.cellY) {
                return lhs.cellY - rhs.cellY;
            } else {
                return lhs.cellX - rhs.cellX;
            }
        }
    };

    public FolderCellLayout getContent() {
        return mContent;
    }

    public int getIconSize() {
        if (mCurrentDragView instanceof BubbleTextView) {
            ((BubbleTextView)mCurrentDragView).getIconSize();
        }
        return mFolderIcon.getIconBounds().height();
    }


    public void showFolderAddView() {
    }

    public void dismissEditingName() {

    }

    public void setImportMode(boolean b) {

    }

    public boolean isImportMode() {
        return false;
    }

    public void onImportModeClick(View v, ShortcutInfo tag) {

    }

    public void onImportAddIconClick() {

    }


    /**
     * Temporary resource held while we don't want to handle info changes
     */
    private class SuppressInfoChanges implements AutoCloseable {

        SuppressInfoChanges() {
            mInfo.removeListener(Folder.this);
        }

        @Override
        public void close() {
            mInfo.addListener(Folder.this);
            updateTextViewFocus();
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        getBackground().setBounds(mBackgroundBounds);
        mScrollbar.draw(canvas);
        super.onDraw(canvas);
    }

    /**
     * Returns a folder which is already open or null
     */
    public static Folder getOpen(Launcher launcher) {
        return launcher.getFolderPagesContainer().getCurrentFolder();
    }

    public void close(boolean b) {
        mContainer.close(b);
    }
/*
    @Override
    protected boolean isOfType(int type) {
        return mContainer.isOfType(type);
    }


    @Override
    protected void handleClose(boolean animate) {
         mContainer.handleClose(animate);
    }
    @Override
    public boolean onControllerInterceptTouchEvent(MotionEvent ev) {
        return mContainer.onControllerInterceptTouchEvent(ev);
    }
    @Override
    public void logActionCommand(int command) {
        mContainer.logActionCommand(command);
    }
*/

    public FolderPagesContainer getContainer() {
        return mContainer;
    }

    public void updateBackgroundBounds() {
        int left = 0;
        int top = isHovering() ? -mContent.getHoverTopPadding() : 0;
        int right = left + getDisplayWidth();
        int bottom = top + getDisplayHeight();
        mBackgroundBounds.set(left, top, right, bottom);
    }

    private void setDragOutlineVisible(final boolean visible) {
        final Drawable background = getBackground();
        if (mDragOutlineAnimator != null) {
            mDragOutlineAnimator.cancel();
        }

        int alpha = background.getAlpha();

        if (visible) {
            if (alpha == 0xFF) {
                return;
            }

            mDragOutlineAnimator = ValueAnimator.ofInt(alpha, 0xFF);
        } else {
            if (alpha == 0) {
                return;
            }

            mDragOutlineAnimator = ValueAnimator.ofInt(alpha, 0);
        }

        mDragOutlineAnimator.setDuration(250);
        mDragOutlineAnimator.addUpdateListener(a-> background.setAlpha((int) a.getAnimatedValue()));
        mDragOutlineAnimator.start();
    }

    public boolean canHover() {
        return !mLauncher.isInEditMode();
    }

    public boolean isHovering() {
        if (mLauncher.isInEditMode()) {
            return false;
        }

        return mContainer.isHovering();
    }

    public void setHovering(boolean isHovering) {
        boolean succeed = mContainer.setHovering(isHovering);
        if (succeed) {
            updateBackgroundBounds();
        }
    }

    private class FolderHover {
        private static final int OVER_SCROLL_RANGE = 100;
        private static final int HOVER_SCROLL_DURATION = 250;
        private static final float STIFFNESS = (STIFFNESS_MEDIUM + STIFFNESS_LOW) / 2;
        private static final float DAMPING_RATIO = DAMPING_RATIO_MEDIUM_BOUNCY;
        private static final float VELOCITY_MULTIPLIER = 0.3f;
        private final FloatPropertyCompat<FolderHover> DAMPED_SCROLL =
                new FloatPropertyCompat<FolderHover>("value") {
                    @Override
                    public float getValue(FolderHover object) {
                        return object.mDampedScrollShift;
                    }

                    @Override
                    public void setValue(FolderHover object, float value) {
                        object.setDampedScrollShift(value);
                    }
                };
        private OverScroller mScroller;
        private SpringAnimation mSpring;
        private float mDampedScrollShift = 0;

        public FolderHover() {
            mScroller = new OverScroller(getContext());
            mSpring = new SpringAnimation(this, DAMPED_SCROLL, 0);
            mSpring.setSpring(new SpringForce(0)
                    .setStiffness(STIFFNESS)
                    .setDampingRatio(DAMPING_RATIO));
        }

        public boolean startScroll() {
            mSpring.skipToEnd();
            return canHover();
        }

        public void scroll(int delta, int[] consumed) {
            boolean hiddenTop = delta > 0 && getScrollY() < 0;
            boolean showTop = delta < 0 && getScrollY() > mContent.getHoverTopPadding() - OVER_SCROLL_RANGE;

            if (hiddenTop || showTop) {
                scrollBy(0, delta);
                consumed[1] = delta;
            }
        }

        public boolean fling(int velocity) {
            if (getScrollY() < 0) {
                mScroller.fling(0, getScrollY(), 0, velocity, 0, 0,
                        mContent.getHoverTopPadding(), 0);
                postInvalidateOnAnimation();
                return true;
            }

            return false;
        }

        public void stop() {
            if (isHovering()) {
                if (getScrollY() <= mContent.getHoverTopPadding() + OVER_SCROLL_RANGE) {
                    mScroller.startScroll(0, getScrollY(), 0,
                            mContent.getHoverTopPadding()-getScrollY());
                    postInvalidateOnAnimation();
                } else {
                    mScroller.startScroll(0, getScrollY(), 0,
                            -getScrollY(), HOVER_SCROLL_DURATION);
                    finishWithSpringAnimation();
                    showScrollbar();
                }

            } else {
                if (getScrollY() >= -OVER_SCROLL_RANGE) {
                    mScroller.startScroll(0, getScrollY(), 0,
                            -getScrollY());
                    postInvalidateOnAnimation();
                } else {
                    mScroller.startScroll(0, getScrollY(), 0,
                            mContent.getHoverTopPadding()- getScrollY(), HOVER_SCROLL_DURATION);
                    finishWithSpringAnimation();
                }
            }

            if (mScroller.getFinalY() == mContent.getHoverTopPadding()
                    || getScrollY() == mContent.getHoverTopPadding()) {
                setHovering(true);
            } else if (mScroller.getFinalY() == 0
                    || getScrollY() == 0) {
                setHovering(false);
            }
        }

        public void computeScroll() {
            if (mScroller.computeScrollOffset()) {
                scrollTo(mScroller.getCurrX(), mScroller.getCurrY());

                if (!awakenScrollBars()) {
                    postInvalidateOnAnimation();
                }
            }
        }

        public boolean drawChild(Canvas canvas, View child, long drawingTime) {
            if (mDampedScrollShift != 0) {
                canvas.translate(0, mDampedScrollShift);
                boolean result = superDrawChild(canvas, child, drawingTime);
                canvas.translate(0, -mDampedScrollShift);
                return result;
            }
            return superDrawChild(canvas, child, drawingTime);
        }

        private void setDampedScrollShift(float shift) {
            if (shift != mDampedScrollShift) {
                mDampedScrollShift = shift;
                invalidate();
            }
        }

        private void finishScrollWithVelocity(float velocity) {
            mSpring.setStartVelocity(velocity);
            mSpring.setStartValue(mDampedScrollShift);
            mSpring.start();
        }

        private void finishWithSpringAnimation() {
            float deltaY = (getScrollY() - mScroller.getFinalY()) * 0.8f;
            finishWithShiftAndVelocity(deltaY, deltaY * VELOCITY_MULTIPLIER);
        }

        private void finishWithShiftAndVelocity(float shift, float velocity) {
            setDampedScrollShift(shift);
            finishScrollWithVelocity(velocity);
        }
    }

    @Override
    public boolean onStartNestedScroll(@NonNull View child, @NonNull View target, int nestedScrollAxes) {
        return mHover.startScroll();
    }

    @Override
    public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed) {
        mHover.scroll(dy, consumed);
    }

    @Override
    public boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY) {
        return mHover.fling((int)velocityY);
    }

    @Override
    public void onStopNestedScroll(@NonNull View child) {
        mHover.stop();
    }

    @Override
    public void scrollTo(int x, int y)
    {
        super.scrollTo(x, Math.min(0, y));
    }

    @Override
    public void computeScroll() {
        mHover.computeScroll();
    }

    boolean superDrawChild(Canvas canvas, View child, long drawingTime) {
        return super.drawChild(canvas, child, drawingTime);
    }

    @Override
    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
        return mHover.drawChild(canvas, child, drawingTime);
    }

    public void scrollToTop() {
        if (isHovering()) {
            scrollTo(0, mContent.getHoverTopPadding());
        } else {
            scrollTo(0, 0);
        }

        mScrollView.scrollTo(0, 0);
        updateBackgroundBounds();
    }

    public void scrollToEnd(Runnable r) {
        View v = mContent.getLastItem();
        scrollToPosition(mContent.getPositionOfChild((BubbleTextView) v), r);
    }

    public void scrollToPosition(int position, Runnable r) {
        mScrollView.scrollToPosition(position, r);
    }

    public boolean isAnimating() {
        return mState == STATE_ANIMATING;
    }

    private Runnable mAnimationCompleteRunnable = null;

    public void setAnimationCompleteRunnable(Runnable runnable) {
        mAnimationCompleteRunnable = runnable;
    }

    public void updateScrollbar() {
        int folderWidth = getFolderWidth();
        int folderHeight = getFolderHeight();
        int contentAreaHeight = getContentAreaHeight();
        int scrollbarWidth = mScrollbar.getBounds().width();
        int top = (int) ((mScrollView.getScrollY() / (float) contentAreaHeight) * folderHeight);
        int bottom = top + (int) ((folderHeight / (float) contentAreaHeight) * folderHeight);
        if (top < bottom) {
            mScrollbar.setBounds(folderWidth - scrollbarWidth, top, folderWidth, bottom);
            showScrollbar();
        }
    }

    private void showScrollbar() {
        if (mScrollbarAnimator != null) {
            mScrollbarAnimator.cancel();
        }
        mScrollbar.setAlpha(0xFF);
        hideScrollbar();
    }

    private void hideScrollbar() {
        if (mScrollbarAnimator != null) {
            mScrollbarAnimator.cancel();
        }

        int alpha = mScrollbar.getAlpha();
        mScrollbarAnimator = ValueAnimator.ofInt(alpha, 0);
        mScrollbarAnimator.setStartDelay(300);
        mScrollbarAnimator.setDuration(250);
        mScrollbarAnimator.addUpdateListener(a-> {
            mScrollbar.setAlpha((int) a.getAnimatedValue());
            invalidate();
        });
        mScrollbarAnimator.start();
    }

    public boolean isCategoryFolder() {
        return false;//mInfo.hasOption(FolderInfo.FLAG_CATEGORY_FOLDER);
    }

    public void updateChildrenDatabase() {
        List<ShortcutInfo> contents = new ArrayList<>(mInfo.contents);
        for (ShortcutInfo info : contents) {
            mLauncher.getModelWriter().addOrMoveItemInDatabase(info,
                    mInfo.id, 0, info.cellX, info.cellY);
        }
    }

    private int getMinimumItemCount() {
        return /*ClassifyHelper.isSmartClassifyEnable() ? 0 :*/ 1;
    }

    public BubbleTextView findShortcutByAppInfo(AppInfo app) {
        ShortcutAndWidgetContainer container = mContent.getShortcutsAndWidgets();
        BubbleTextView shortcut = container.findShortcutByAppInfo(app);
        if (shortcut != null) {
            return shortcut;
        }

        return null;
    }

    public boolean location(final BubbleTextView app) {
        if (isOpen()) {
            locationAfterOpen(app);
        } else {
            setAnimationCompleteRunnable(()-> locationAfterOpen(app));
            animateOpen();
        }

        return true;
    }
    public boolean isOpen() {
        return mContainer.isOpen();
    }
    private void locationAfterOpen(final BubbleTextView app) {
        final int position = mContent.getPositionOfChild(app);

        scrollToPosition(position, ()-> {
            cancelLocateAnimation();
            mLocateAnimation = LocateAnimationHelper.getLocateAnimation(app);
            if (mLocateAnimation != null) {
                mLocateAnimation.start();
            }
        });
    }

    private void cancelLocateAnimation() {
        if (mLocateAnimation != null && mLocateAnimation.isRunning()) {
            mLocateAnimation.cancel();
        }
    }

    public FolderHover getHover() {
        return mHover;
    }
}
